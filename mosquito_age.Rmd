---
title: "Figure 5"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

## Packages

```{r message = FALSE}
library(readr)
library(dplyr)
library(purrr)
library(magrittr)
library(mgcv)
library(parallel)
```

## Capacity formula

The expression of the vectorial capacity as a function of as:

$$
C(a) = M\times B^2  \frac{p(a)}{g(a)} e^{-\frac{g(a)}{m(a)}}
$$
Where $M = 20$ is the ratio of mosquitoes to humans and $B = 1/3$ is the
mosquito biting rate. These parameters were not studied here and will thus be
assumed to be constants independent of age. Sporozoite prevalences $p(a)$ is
informed by experiment 1, mosquitoes survival rates $g(a)$ are informed by
experiment 2 and the parasite maturation rate is informed by experiment 3.
We will assume that the vector competence and survival and the parasite
maturation are independent from each other. We'll further assume that $p(a)$
follows a beta distribution, the parameters of which will be estimated from the
binomial estimate and its confidence interval from the presence/absence raw data
and we will assume too that $m$ follows a gamma distribution, the parameters of
which are estimated in a similar way. Values for $p(a)$ and $m$ will then be
randomly drawn from these beta and gamma distributions respectively. As for the
mosquito survival rates, we will simply compute the expected life expectancy
from the non-parametrically bootstrapped data. This allows to preserve as well as
possible the original distribution of the experimental data.

## Data from experiment 1

Loading and preparing the data:

```{r message = FALSE}
fig2 <- "data/fig2_sporozoite_data.txt" |>
  read_delim() |> 
  filter(age_class != "8-day-old") |> 
  mutate(intensity = 10^(-(Ct - 40) / 3.3))
```

The names of the age classes:

```{r}
age_names <- sort(unique(fig2$age_class))
```

A function that converts confidence intervals boundary values of a proportion
into parameters of a probability distribution:

```{r}
ci2pars <- function(ci, f, pars, p = .95) {
  p <- (1 - p) / 2
  
  f_par <- function(par1, par2) {
    c(f(p, par1, par2), f(1 - p, par1, par2))
  }

  f_fit <- function(pars) {
    sum((f_par(pars[1], pars[2]) - ci)^2)
  }
  
  optim(pars, f_fit)$par
}
```

The shape parameters of the beta distribution of the mean sporozoites
prevalences ($p(a)$):

```{r warning = FALSE}
p_par0 <- fig2 |> 
  group_by(age_class) |> 
  summarize(x   = sum(positive), n = length(positive)) |> 
  mutate(prop   = map2(x, n, prop.test),
         ci     = map(prop, extract2, "conf.int"),
         shapes = map(ci, ci2pars, qbeta, 1:2))

p_par <- p_par0 |> 
  pull(shapes) |> 
  setNames(age_names)
```

The estimate and confidence interval:

```{r}
p_par0$prop |>
  map(extract, c("estimate", "conf.int")) |> 
  map_dfr(unlist)
```

A function that converts a vector into a 1-row tibble:

```{r}
vec2tibble <- function(x, names = NULL) {
  out <- as_tibble(matrix(x, 1))
  if (is.null(names)) return(out)
  setNames(out, names)
}
```

The parameters of the beta distribution:

```{r warning = FALSE}
p_par |> 
  map_dfr(vec2tibble, paste("shape", 1:2), .id = "group")
```


## Experiment 2

Loading and preparing the data:

```{r message = FALSE}
fig3 <- "data/fig3_survival_data.txt" |>
  read_delim() |> 
  filter(age_class != "8-day-old",
         !(age_class == "4-day-old" & infection_status != "Exposed-infected")) |> 
  mutate(group = paste(age_class, infection_status, sep = " | ")) |> 
  select(group, daysPI)
```

Generating the mortality data:

```{r}
mortality <- fig3 |> 
  group_by(group) |> 
  group_split() |> 
  map(pull, daysPI) |> 
  setNames(sort(unique(fig3$group)))
```


## Experiment 3

Loading and preparing the data:

```{r message = FALSE}
fig4 <- read_delim("data/fig4_EIP_data.txt")
```

```{r fig4a, message = FALSE}
fig4a <- fig4 |>
  select(dpi, spz) |> 
  na.exclude() |> 
  mutate_at("spz", as.logical)
```

The parameters of the gamma distribution that models the distribution of the
maturation rate:

```{r compute_m, warning = FALSE, dependson = "fig4a"}
ci_val <- .95
alpha <- (1 - ci_val) / 2

mod <- glm(spz ~ dpi, binomial, fig4a)
invtransf <- family(mod)$linkinv

xs <- seq(min(fig4a$dpi), max(fig4a$dpi), le = 1000)
ys <- predict(mod, data.frame(dpi = xs), se.fit = TRUE)

nb_data <- nrow(mod$data)

ci <- tibble(xs  = xs,
             fit = invtransf(ys$fit),
             low = invtransf(ys$fit + qt(alpha, nb_data) * ys$se.fit),
             upp = invtransf(ys$fit + qt(1 - alpha, nb_data) * ys$se.fit))

tmp <- c(filter(ci, .5 < upp)$xs[1], filter(ci, .5 < low)$xs[1])

m <- 1 / ci2pars(tmp, qgamma, 1:2)
```

Estimate and confidence interval:

```{r}
ci |> 
  mutate(d = abs(fit - .5)) |> 
  arrange(d) |> 
  pull(xs) |> 
  first() |> 
  c(tmp)
```

## Simulating data

The simulator of a distribution of values of the vectorial capacity:

```{r simulator, dependson = "compute_m"}
M <- 20
B <- 1 / 3
MB2 <- M * B * B

simulate <- function(p, g, N = 1e6) {
  p_val <- do.call(rbeta, c(list(N), unname(p)))
  g_val <- replicate(N, 1 / mean(sample(g, replace = TRUE)))
  m_val <- do.call(rgamma, c(list(N), m))
  MB2 * p_val * exp(-g_val / m_val) / g_val
}
```

A function that does the bootstrapping, together with diagnostic plots:

```{r}
bootstrapping <- function(x, title, n = 1e4) {
  marc <- replicate(n, 1 / mean(sample(x, replace = TRUE)))
  plot(cummean(marc), type = "l", ylab = "cumulative mean of the mean", main = title)
  quantile(marc, c(.025, .5, .975))
}
```

Confidence intervals (5"):

```{r}
opar <- par(mfrow = c(2, 2))
map2_dfr(mortality, names(mortality), bootstrapping)
par(opar)
```

Performing the simulations for the 4 groups (47"):

```{r simulations, dependson = "simulator"}
sim_output <- mcmapply(simulate, rep(p_par, c(3, 1)), mortality, SIMPLIFY = FALSE, mc.cores = 4) |> 
  setNames(c("sim_age12_ExpInf", "sim_age12_ExpNoinf", "sim_age12_Uninf", "sim_age4"))
```

If you are on Windows and the above line does not work, do this instead:

```{r eval = FALSE}
sim_output <- mapply(simulate, rep(p_par, c(3, 1)), mortality, SIMPLIFY = FALSE) |> 
  setNames(c("sim_age12_ExpInf", "sim_age12_ExpNoinf", "sim_age12_Uninf", "sim_age4"))
```

Checking that stationarity has been reached:

```{r dependson = "simulations"}
opar <- par(mfrow = c(2, 2))
walk2(sim_output, names(sim_output),
      ~ plot(cummean(.x), main = .y, type = "l", ylab = "mean"))
par(opar)
```

The ranges of values for the simulated vectorial capacities:

```{r dependson = "simulations"}
map_dfr(sim_output,
        ~ setNames(as_tibble(matrix(range(.x), 1)), c("min", "max")),
        .id = "group")
```

The means:

```{r}
map_dbl(sim_output, mean)
```

A function that calculates the proportion of the values of a vector `x` that are
below a threshold `t`:

```{r}
prop_below_th <- function(x, t = 1) length(x[x < t]) / length(x)
```

Proportions below 1:

```{r}
map_dbl(sim_output, prop_below_th)
```

A function that selects the values of a vector `s` above or equal a threshold
value `t`:

```{r}
above_threshold <- function(x, t = 1) x[x >= t]
```

The means for values above 1:

```{r}
map_dbl(sim_output, ~ mean(above_threshold(.x)))
```

A function that computes the standard error of the mean:

```{r}
stderror <- function(x) sd(x) / sqrt(length(x))
```

Standard errors of the mean:

```{r}
map_dbl(sim_output, ~ stderror(above_threshold(.x)))
```

A function that adds boxplots to a figure:

```{r add_boxplot}
add_boxplot <- function(x, y, f = log10, t = 1e-20, eps = .1, lwd = 2, col = 1) {
  x <- as.vector(boxplot(f(above_threshold(x, t)), plot = FALSE)$stats)
  segments2 <- function(...) segments(..., lwd = lwd, col = col)
  segments2(0, y, x[2], y)
  segments2(x[4], y, x[5], y)
  segments2(x[3], y - eps, x[3], y + eps)
  polygon(c(x[2], x[4], x[4], x[2]),
          rep(c(y - eps, y + eps), each = 2),
          lwd = lwd, border = col, col = adjustcolor(col, .5))
}
```

Graph parameters:

```{r graph_par}
f <- log10
from <- 0
to <- log10(60)
```

Computing densities of transformed simulated VC data:

```{r computes_density, dependson = "graph_par"}
densities <- map(sim_output, ~ density(f(above_threshold(.x, 10^from)), from = from, to = to))
```

Figure 5:

```{r dependson = "graph_par", dependson = "computes_density", dependson = "add_boxplot", dependson = "simulations"}
y0 <- 7.9
y_step <- .31
eps <- .1

lines2 <- function(...) lines(..., lwd = 2)

plot(NA, xlim = c(from, to), ylim = c(0, 9), xaxs = "i", yaxs = "i",
     xlab = "vectorial capacity", ylab = "density", axes = FALSE)

ats <- c(1:10, 2:10 * 10)
axis(1, log10(ats), ats)
axis(2)

walk2(densities, c(2, 3, 4, 1), ~ with(.x, lines2(x, y, col = .y)))

ind <- c(2, 3, 1, 4)
pwalk(list(sim_output[ind], (0:3), c(2, 3, 4, 1)[ind]),
      function(x, y, z) add_boxplot(x, y0 + y * y_step, col = z, eps = eps))

legend(0, 7.4, cex = .95,
       legend = c("  4-day-old observed",
                  "12-day-old observed",
                  "12-day-old with survival of uninfected controls",
                  "12-day-old with survival of exposed-uninfected"),
       col = c(1, 2, 4, 3), lty = 1, lwd = 2, bty = "n")
```


## Figure 5SB

The inverse logit (i.e. logistic) function:
  
```{r}
inverse_logit <- function(x) {
  exp(x) / (1 + exp(x))
}
```

A function that computes proportions estimates together with confidence
intervals:

```{r}
proportions <- function(x) {
  models <- x |> 
    group_by(total_oocyst) |> 
    group_map(~ glm(matrix(c(broken_oocyst, oocyst), ncol = 2) ~ 1, binomial, .x))
  
  estimates <- models |> 
    map(coef) |> 
    map(inverse_logit) |> 
    bind_rows()
  
  ci <- models |> 
    map(confint) |> 
    map(inverse_logit) |> 
    bind_rows()
  
  cbind(sort(unique(x$total_oocyst)), estimates, ci) |> 
    setNames(c("total_oocyst", "estimate", "lower", "upper"))
}
```

A function that models the data:

```{r}
modelling <- function(x, bs = "tp") {
  out <- mgcv::gam(matrix(c(broken_oocyst, oocyst),
                          ncol = 2) ~ s(total_oocyst, bs = bs), binomial, x)
  out$data <- x
  out
}
```

Where the possible values for `bs` are:

* `tp`: thin plate
* `ts`: thin plate with a smoothing penalty
* `ds`: Duchon spline (generalization of the thin plate)
* `cr`: cubic regression
* `cs`: cubic regression with a shrinkage
* `cc`: cyclic cubic regression
* `sos`: splines on a sphere
* `bs`: B-spline
* `ps`: P-spline
* `cp`: cyclic P-spline
* `re`: random effect
* `mrf`: Markov random field
* `gp`: Gaussian process
* `so`: soap film smooths

A function that computes the predictions of a model:

```{r}
predictions <- function(x, ci = .95) {
  data <- x$data
  qt_val <- qt(1 - (1 - ci) / 2, nrow(data))
  xs <- seq(min(data$total_oocyst), max(data$total_oocyst), le = 512)

  predict(x, data.frame(total_oocyst = xs), se.fit = TRUE) |> 
    extract(c("fit", "se.fit")) |> 
    as_tibble() |> 
    bind_cols(total_oocyst = xs) |> 
    mutate(lower = inverse_logit(fit - qt_val * se.fit),
           upper = inverse_logit(fit + qt_val * se.fit),
           fit   = inverse_logit(fit)) |> 
    select(-se.fit) |> 
    select(total_oocyst, everything())
}
```

A tuned version of the `polygon()` function:

```{r}
polygon2 <- function(x, y1, y2, col = 1, alpha = .2, ...) {
  polygon(c(x, rev(x)), c(y1, rev(y2)), border = NA,
          col = adjustcolor(col, alpha), ...)
}
```

A function that adds a model predictions to a plot:

```{r}
add_predictions <- function(x, col = 1) {
  with(x, {
    polygon2(total_oocyst, lower, upper, col)
    lines(total_oocyst, fit, col = col)
  })
}
```

A tuning of `arrows()`:

```{r}
arrows2 <- function(...) arrows(..., length = .05, angle = 90, code = 3)
```

A function that makes the figure with a given smoother:

```{r}
plot_proportions <- function(props, eps = .15) {
  props |> 
  filter(age_class == "4-day-old") |> 
  with(plot(total_oocyst - eps, estimate, ylim = 0:1,
            xlab = "total number of oocysts",
            ylab = "proportion of ruptured oocysts"))

  props |> 
    filter(age_class == "12-day-old") |>
    with(points(total_oocyst + eps, estimate, col = 2))
  
  props |> 
    filter(age_class == "4-day-old", !is.nan(upper)) |>
    with(arrows2(total_oocyst - eps, lower, total_oocyst - eps, upper))
  
  props |> 
    filter(age_class == "12-day-old", !is.nan(upper)) |>
    with(arrows2(total_oocyst + eps, lower, total_oocyst + eps, upper, col = 2))
}
```

```{r}
add_model_predictions <- function(data, s) {
  data |> 
    group_by(age_class) |> 
    group_split() |> 
    map(modelling, s) |> # tp, cr, bs, ps
    map(predictions) |> 
    walk2(2:1, add_predictions)
}
```

Make figure S5B:

```{r}
make_figS5B <- function(props, data, s = "tp", eps = .15) {
  plot_proportions(props, eps = .15)
  add_model_predictions(data, s)
  legend("topleft", legend = c("4-day-old", "12-day-old"),
         col = 1:2, lty = 1, bty = "n")
}
```

Preparing the data:

```{r}
fig4b <- fig4 |> 
  select(age_class, oocyst, broken_oocyst) |> 
  na.exclude() |> 
  mutate(total_oocyst = oocyst + broken_oocyst) |> 
  filter(total_oocyst > 0)
```

Computing the proportions of ruptured oocysts per age class and total number of
oocysts:

```{r message = FALSE}
props <- fig4b |> 
  group_by(age_class) |> 
  group_modify(~ proportions(.x)) |> 
  ungroup()
```

Make figure S5B:

```{r}
make_figS5B(props, fig4b, "tp")
title("thin plate")
make_figS5B(props, fig4b, "cr")
title("cubic regression")
make_figS5B(props, fig4b, "bs")
title("B-spline")
make_figS5B(props, fig4b, "ps")
title("P-spline")
```

## Titi

```{r}
eip <- fig4 |> 
  filter(8 < dpi, dpi < 15, oocyst > 0) |> 
  mutate(total_oocyst = broken_oocyst + oocyst,
         prop = broken_oocyst / total_oocyst)
```

```{r}
with(eip, plot(total_oocyst, prop))
```

Relaxing filter:

```{r}
fig4 |> 
#  filter(8 < dpi, dpi < 15, oocyst > 0) |> 
  mutate(total_oocyst = broken_oocyst + oocyst,
         prop = broken_oocyst / total_oocyst) |> 
  with(plot(total_oocyst, prop))
```

